syntax = "proto3";

package graphs;

// First install protobuf-compiler package on linux
// Compile with:
// protoc --proto_path=./ --cpp_out=./lib/protos GraphData.proto
// To use optional add --experimental_allow_proto3_optional

// Gzip compression while serializing of Message in C++ with class GzipOutputStream of libprotoc
//      GzipOutputStream gzipOutputStream {<ostream instance>};
//      messageObject.SerializeToZeroCopyStream(&gzipOutputStream);

import "google/protobuf/any.proto";

message Vertex {
    uint64 uid = 1;
    double x = 2;
    double y = 3;
    double z = 4;

    map<string, string> attributes = 5;
}

message Edge {
    uint64 uid = 1;
    uint64 inVertexUid = 2;
    uint64 outVertexUid = 3;
    // repeated double cost = 4;
    // If number not enough for costs: repeated EdgeCost cost = 4;
    map<uint32, double> cost = 4;

    map<string, string> attributes = 5;
}

message Graph {
    uint64 uid = 1;
    repeated Edge edgeList = 2;
    repeated Vertex vertexList = 3;

    map<string, string> attributes = 4;
}

message ShortPathRequest {
    Graph graph = 1;
    uint64 startIndex = 2;
    uint64 endIndex = 3;
};

message ShortPathResponse {
    Graph graph = 1;
};

// Add more request and response types

message RequestContainer {
    enum RequestType {
        SHORTEST_PATH = 0;
        // Add more modes/types
    };

    RequestType type = 1;

    google.protobuf.Any request = 2;
};

message ResponseContainer {
    enum StatusCode {
        OK = 0;
        ERROR = 1;
        // TODO Add  more error codes
    };

    enum ResponseType {
        SHORTEST_PATH = 0;
        // Add more modes/types
    };

    StatusCode status = 1;

    ResponseType type = 2;

    google.protobuf.Any response = 3;
};
